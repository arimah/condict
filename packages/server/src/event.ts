import {
  LanguageId,
  LemmaId,
  DefinitionId,
  PartOfSpeechId,
  InflectionTableId,
  TagId,
} from './graphql';

/**
 * A generic dictionary event emitter.
 */
export interface DictionaryEventEmitter {
  /**
   * Emits a dictionary event.
   * @param event The event to emit.
   */
  emit(event: DictionaryEvent): void;

  /**
   * Emits every event in the specified iterable.
   * @param events The events to emit.
   */
  emitAll(events: Iterable<DictionaryEvent>): void
}

/**
 * A batch of dictionary events, as generated by a GraphQL operation. Events are
 * batched mainly for performance, to avoid sending one message per event to
 * each WebSocket client (in the case of an HTTP server; for local servers it
 * makes less of a difference).
 */
export interface DictionaryEventBatch {
  readonly type: 'batch';
  /** The events in the batch. */
  readonly events: readonly DictionaryEvent[];
}

/**
 * A dictionary event.
 *
 * Dictionary events are emitted when resources in the dictionary change. Events
 * encapuslate additions (action == 'create'), updates (action == 'update') and
 * deletions (actions == 'delete'). Dictionary events are fairly high-level, and
 * cannot be used for fine-grained updates. They contain information about what
 * was done and to what resource, but do not contain e.g. changed fields. Events
 * should be used to determine whether the client needs to re-fetch data, not to
 * patch already fetched data.
 *
 * Update events on a child resource do not automatically cause update events on
 * the parent resource. For instance, renaming an inflection table will cause an
 * InflectionTableEvent to be emitted, but *not* a PartOfSpeechEvent on the part
 * of speech that the table is in. A page that shows a part of speech's name and
 * tables should therefore subscribe to updates on the part of speech *and* on
 * inflection table events where partOfSpeechId has the relevant value. This
 * gives the client more flexibility in choosing which updates to subscribe to.
 *
 * Deletions propagate downwards. If a part of speech is deleted, events will
 * also be emitted for the deletion of any inflection tables that are contained
 * in that part of speech.
 */
export type DictionaryEvent =
  | LanguageEvent
  | LemmaEvent
  | DefinitionEvent
  | PartOfSpeechEvent
  | InflectionTableEvent
  | TagEvent;

export const DictionaryEvent = {
  /**
   * Gets a key for the event that can be used to deduplicate equivalent events.
   * @param event The event to get a key for.
   * @return The event key.
   */
  key(event: DictionaryEvent): string {
    // Resources cannot move from one parent to another. When comparing equality
    // we only really have to look at the `id`, and not `languageId`, `lemmaId`,
    // `partOfSpeechId`, or anything else.
    return `${event.type} ${event.action} ${event.id}`;
  },
} as const;

/** The action that was performed on the resource. */
export type EventAction = 'create' | 'update' | 'delete';

interface BaseEvent<T extends string> {
  /** The resource type. */
  readonly type: T;
  /** The action that was performed. */
  readonly action: EventAction;
}

export interface LanguageEvent extends BaseEvent<'language'> {
  /** The ID of the language. */
  readonly id: LanguageId;
}

export interface LemmaEvent extends BaseEvent<'lemma'> {
  /** The ID of the lemma. */
  readonly id: LemmaId;
  /** The ID of the language that the lemma belongs/belonged to. */
  readonly languageId: LanguageId;
}

export interface DefinitionEvent extends BaseEvent<'definition'> {
  /** The ID of the definition. */
  readonly id: DefinitionId;
  /** The ID of the lemma that the definition belongs/belonged to. */
  readonly lemmaId: LemmaId;
  /** The ID of the language that the definition belongs/belonged to. */
  readonly languageId: LanguageId;
}

export interface PartOfSpeechEvent extends BaseEvent<'partOfSpeech'> {
  /** The ID of the part of speech. */
  readonly id: PartOfSpeechId;
  /** The ID of the language that the part of speech belongs/belonged to. */
  readonly languageId: LanguageId;
}

export interface InflectionTableEvent extends BaseEvent<'inflectionTable'> {
  /** The ID of the inflection table. */
  readonly id: InflectionTableId;
  /**
   * The ID of the part of speech that the inflection table belongs/belonged to.
   */
  readonly partOfSpeechId: PartOfSpeechId;
  /** The ID of the language that the inflection table belongs/belonged to. */
  readonly languageId: LanguageId;
}

export interface TagEvent extends BaseEvent<'tag'> {
  /** The ID of the tag. */
  readonly id: TagId;
}
