// In this file, we use `number` instead of the dedicated ID types. We don't
// expose the generated ID types, and event types are exported publicly, so we
// can't make use of ID types here.

/**
 * A generic dictionary event emitter.
 */
export interface DictionaryEventEmitter {
  /**
   * Emits a dictionary event.
   * @param event The event to emit.
   */
  emit(event: DictionaryEvent): void;

  /**
   * Emits every event in the specified iterable.
   * @param events The events to emit.
   */
  emitAll(events: Iterable<DictionaryEvent>): void
}

/**
 * A batch of dictionary events, as generated by a GraphQL operation. Events are
 * batched mainly for performance, to avoid sending one message per event to
 * each WebSocket client (in the case of an HTTP server; for local servers it
 * makes less of a difference).
 */
export interface DictionaryEventBatch {
  readonly type: 'batch';
  /** The events in the batch. */
  readonly events: readonly DictionaryEvent[];
}

/**
 * A dictionary event.
 *
 * Dictionary events are emitted when resources in the dictionary change. Events
 * encapuslate additions (action == 'create'), updates (action == 'update') and
 * deletions (actions == 'delete'). Dictionary events are fairly high-level, and
 * cannot be used for fine-grained updates. They contain information about what
 * was done and to what resource, but do not contain all changed fields. Events
 * should be used to determine whether the client needs to re-fetch data, not to
 * patch already fetched data.
 *
 * Update events on a child resource do not automatically cause update events on
 * the parent resource. For instance, renaming an inflection table will cause an
 * InflectionTableEvent to be emitted, but *not* a PartOfSpeechEvent on the part
 * of speech that the table is in. A page that shows a part of speech's name and
 * tables should therefore subscribe to updates on the part of speech *and* on
 * inflection table events where partOfSpeechId has the relevant value. This
 * gives the client more flexibility in choosing which updates to subscribe to.
 *
 * Deletions also do *not* propagate downwards. If a part of speech is deleted,
 * no events will be emitted for the deletion of the inflection tables that are
 * contained in that part of speech. This is done for performance reasons, as
 * the deletion of a resource with many children may otherwise require thousands
 * of events (particularly for languages). However, lemma delete events *are*
 * triggered in response to definition edits, as that is the only place where
 * lemmas are created and deleted.
 */
export type DictionaryEvent =
  | LanguageEvent
  | LemmaEvent
  | DefinitionEvent
  | PartOfSpeechEvent
  | InflectionTableEvent
  | TagEvent
  | DefinitionTagEvent;

export const DictionaryEvent = {
  /**
   * Gets a key for the event that can be used to deduplicate equivalent events.
   * @param event The event to get a key for.
   * @return The event key.
   */
  key(event: DictionaryEvent): string {
    return JSON.stringify(event);
  },
} as const;

/** The action that was performed on the resource. */
export type EventAction = 'create' | 'update' | 'delete';

interface BaseEvent<T extends string, A extends EventAction = EventAction> {
  /** The resource type. */
  readonly type: T;
  /** The action that was performed. */
  readonly action: A;
}

export interface LanguageEvent extends BaseEvent<'language'> {
  /** The ID of the language. */
  readonly id: number;
}

export interface LemmaEvent extends BaseEvent<'lemma'> {
  /** The ID of the lemma. */
  readonly id: number;
  /** The ID of the language that the lemma belongs/belonged to. */
  readonly languageId: number;
}

export type DefinitionEvent =
  | CreateOrDeleteDefinitionEvent
  | UpdateDefinitionEvent;

export interface CreateOrDeleteDefinitionEvent extends
  BaseEvent<'definition', 'create' | 'delete'>
{
  /** The ID of the definition. */
  readonly id: number;
  /** The ID of the lemma that the definition belongs/belonged to. */
  readonly lemmaId: number;
  /** The ID of the part of speech that the definition belongs/belonged to. */
  readonly partOfSpeechId: number;
  /** The ID of the language that the definition belongs/belonged to. */
  readonly languageId: number;
}

export interface UpdateDefinitionEvent extends
  BaseEvent<'definition', 'update'>
{
  /** The ID of the definition. */
  readonly id: number;
  /** The ID of the lemma that the definition belongs to. */
  readonly lemmaId: number;
  /**
   * The ID of the lemma that the definition previously belonged to. If this
   * value is the same as `lemmaId`, then the definition has not moved to a new
   * lemma.
   */
  readonly prevLemmaId: number;
  /** The ID of the part of speech that the definition belongs to. */
  readonly partOfSpeechId: number;
  /**
   * The ID of the part of speech that the definition previously belonged to.
   * If this value is the same as `partOfSpeechId`, then the definition has not
   * moved to a new part of speech.
   */
  readonly prevPartOfSpeechId: number;
  /** The ID of the language that the definition belongs to. */
  readonly languageId: number;
}

export interface PartOfSpeechEvent extends BaseEvent<'partOfSpeech'> {
  /** The ID of the part of speech. */
  readonly id: number;
  /** The ID of the language that the part of speech belongs/belonged to. */
  readonly languageId: number;
}

export interface InflectionTableEvent extends BaseEvent<'inflectionTable'> {
  /** The ID of the inflection table. */
  readonly id: number;
  /**
   * The ID of the part of speech that the inflection table belongs/belonged to.
   */
  readonly partOfSpeechId: number;
  /** The ID of the language that the inflection table belongs/belonged to. */
  readonly languageId: number;
}

export interface TagEvent extends BaseEvent<'tag'> {
  /** The ID of the tag. */
  readonly id: number;
}

/**
 * Occurs when the tags associated with a definition are changed. When a
 * definition is created, a DefinitionTagEvent is emitted with prevTagIds set
 * to the empty array. Likewise, a deleted definition emits one of these events
 * with nextTagIds set to the empty array. Both of the aforementioned events can
 * also occur when a definition is edited to receive its first tags or lose all
 * of its tags.
 */
export interface DefinitionTagEvent extends
  BaseEvent<'definitionTag', 'update'>
{
  /** The ID of the definition whose tags were edited. */
  readonly definitionId: number;
  /** The ID of the lemma that the definition belongs/belonged to. */
  readonly lemmaId: number;
  /** The ID of the language that the definition belongs to. */
  readonly languageId: number;
  /** The IDs of the tags that were previously assigned to the definition. */
  readonly prevTagIds: readonly number[];
  /** The IDs of the tags that are now assigned to the definition. */
  readonly nextTagIds: readonly number[];
}
