import {
  LanguageId,
  LemmaId,
  DefinitionId,
  PartOfSpeechId,
  InflectionTableId,
  TagId,
} from './graphql';

/**
 * A generic dictionary event emitter.
 */
export interface DictionaryEventEmitter {
  /**
   * Emits a dictionary event.
   * @param event The event to emit.
   */
  emit(event: DictionaryEvent): void;

  /**
   * Emits every event in the specified iterable.
   * @param events The events to emit.
   */
  emitAll(events: Iterable<DictionaryEvent>): void
}

/**
 * A batch of dictionary events, as generated by a GraphQL operation. Events are
 * batched mainly for performance, to avoid sending one message per event to
 * each WebSocket client (in the case of an HTTP server; for local servers it
 * makes less of a difference).
 */
export interface DictionaryEventBatch {
  readonly type: 'batch';
  /** The events in the batch. */
  readonly events: readonly DictionaryEvent[];
}

/**
 * A dictionary event.
 *
 * Dictionary events are emitted when resources in the dictionary change. Events
 * encapuslate additions (action == 'create'), updates (action == 'update') and
 * deletions (actions == 'delete'). Dictionary events are fairly high-level, and
 * cannot be used for fine-grained updates. They contain information about what
 * was done and to what resource, but do not contain e.g. changed fields. Events
 * should be used to determine whether the client needs to re-fetch data, not to
 * patch already fetched data.
 *
 * Update events on a child resource do not automatically cause update events on
 * the parent resource. For instance, renaming an inflection table will cause an
 * InflectionTableEvent to be emitted, but *not* a PartOfSpeechEvent on the part
 * of speech that the table is in. A page that shows a part of speech's name and
 * tables should therefore subscribe to updates on the part of speech *and* on
 * inflection table events where partOfSpeechId has the relevant value. This
 * gives the client more flexibility in choosing which updates to subscribe to.
 *
 * Deletions also do *not* propagate downwards. If a part of speech is deleted,
 * no events will be emitted for the deletion of the inflection tables that are
 * contained in that part of speech. This is done for performance reasons, as
 * the deletion of a resource with many children may otherwise require thousands
 * of events (particularly for languages). However, lemma delete events *are*
 * triggered in response to definition edits, as that is the only place where
 * lemmas are created and deleted.
 */
export type DictionaryEvent =
  | LanguageEvent
  | LemmaEvent
  | DefinitionEvent
  | PartOfSpeechEvent
  | InflectionTableEvent
  | TagEvent;

export const DictionaryEvent = {
  /**
   * Gets a key for the event that can be used to deduplicate equivalent events.
   * @param event The event to get a key for.
   * @return The event key.
   */
  key(event: DictionaryEvent): string {
    // Resources generally can't move from one parent to another. When creating
    // this key, we generally don't have to look at the IDs of parent resources.
    // However, definitions can move between lemmas, which we must take into
    // account. In the extremely unlikely case that a definition is added twice
    // in the same request, we might get *two* updates with a total of three
    // different lemma IDs. We can't overwrite either.
    if (event.type === 'definition' && event.action === 'update') {
      const {type, action, id, lemmaId, prevLemmaId} = event;
      return `${type} ${action} ${id} ${lemmaId} ${prevLemmaId}`;
    }
    return `${event.type} ${event.action} ${event.id}`;
  },
} as const;

/** The action that was performed on the resource. */
export type EventAction = 'create' | 'update' | 'delete';

interface BaseEvent<T extends string, A extends EventAction = EventAction> {
  /** The resource type. */
  readonly type: T;
  /** The action that was performed. */
  readonly action: A;
}

export interface LanguageEvent extends BaseEvent<'language'> {
  /** The ID of the language. */
  readonly id: LanguageId;
}

export interface LemmaEvent extends BaseEvent<'lemma'> {
  /** The ID of the lemma. */
  readonly id: LemmaId;
  /** The ID of the language that the lemma belongs/belonged to. */
  readonly languageId: LanguageId;
}

export type DefinitionEvent =
  | CreateOrDeleteDefinitionEvent
  | UpdateDefinitionEvent;

export interface CreateOrDeleteDefinitionEvent extends
  BaseEvent<'definition', 'create' | 'delete'>
{
  /** The ID of the definition. */
  readonly id: DefinitionId;
  /** The ID of the lemma that the definition belongs/belonged to. */
  readonly lemmaId: LemmaId;
  /** The ID of the language that the definition belongs/belonged to. */
  readonly languageId: LanguageId;
}

export interface UpdateDefinitionEvent extends
  BaseEvent<'definition', 'update'>
{
  /** The ID of the definition. */
  readonly id: DefinitionId;
  /** The ID of the lemma that the definition belongs/belonged to. */
  readonly lemmaId: LemmaId;
  /**
   * The ID of the lemma that the definition previously belonged to. If this
   * value is the same as `lemmaId`, then the definition has not moved to a new
   * lemma.
   */
  readonly prevLemmaId: LemmaId;
  /** The ID of the language that the definition belongs/belonged to. */
  readonly languageId: LanguageId;
}

export interface PartOfSpeechEvent extends BaseEvent<'partOfSpeech'> {
  /** The ID of the part of speech. */
  readonly id: PartOfSpeechId;
  /** The ID of the language that the part of speech belongs/belonged to. */
  readonly languageId: LanguageId;
}

export interface InflectionTableEvent extends BaseEvent<'inflectionTable'> {
  /** The ID of the inflection table. */
  readonly id: InflectionTableId;
  /**
   * The ID of the part of speech that the inflection table belongs/belonged to.
   */
  readonly partOfSpeechId: PartOfSpeechId;
  /** The ID of the language that the inflection table belongs/belonged to. */
  readonly languageId: LanguageId;
}

export interface TagEvent extends BaseEvent<'tag'> {
  /** The ID of the tag. */
  readonly id: TagId;
}
